/**
 * @module main
 * @description Main application entry point for ViteSSG-based static site generation.
 * This module initializes Vue 3, Vue Router, Pinia state management, and all application modules.
 * It handles both server-side rendering (SSR) during build and client-side hydration.
 *
 * @remarks
 * - Routes are generated by `vite-plugin-pages` using file-based routing
 * - Layouts are handled by `vite-plugin-vue-layouts`
 * - State hydration is managed through Pinia's SSR support
 * - Optional reCAPTCHA integration is available via environment variables
 */

import { createPinia } from 'pinia'
import { setupLayouts } from 'virtual:generated-layouts'
import generatedRoutes from 'virtual:generated-pages'
import { ViteSSG } from 'vite-ssg'
import { install } from 'vue3-recaptcha-v2'
import { useNotification } from './composables/useNotification'
/**
 * vite-plugin-pages:         Generating routing information
 * virtual:generated-pages:   It comes from tsconfig.json-compilerOptions-types -> "vite-plugin-pages/client"
 * virtual:generated-layouts: It comes from tsconfig.json-compilerOptions-types -> "vite-plugin-vue-layouts/client"
 */
import '/@/styles/font.css'
import '/@/styles/main.css'
import App from '/@/App.vue'

/**
 * @type {import('vue-router').RouteRecordRaw[]}
 * @description All application routes with layouts applied.
 * Generated from files in `src/pages/` and wrapped with layouts from `src/layouts/`.
 */
const routes = setupLayouts(generatedRoutes)

// Debug: Log all routes in development
if (import.meta.env.DEV) {
  console.log('[main.ts] Generated routes:')
  routes.forEach((r) => {
    console.log(`  - ${r.path} (name: ${r.name || 'N/A'}, component: ${r.component})`)
  })
}

/**
 * @interface Module
 * @description Module registry type for dynamically loaded user modules.
 * Modules are loaded from `src/modules/` directory and installed during app initialization.
 */
interface Module extends Record<string, Record<string, UserModule>> {}

/**
 * @function createApp
 * @description Creates and configures the ViteSSG application instance.
 * Sets up Pinia state management, Vue Router, reCAPTCHA (if configured), and all user modules.
 *
 * @returns {import('vite-ssg').ViteSSGContext} The configured ViteSSG application context
 *
 * @example
 * ```typescript
 * // The app is automatically created and mounted by ViteSSG
 * // No manual instantiation required
 * ```
 *
 * @remarks
 * - Pinia state is serialized during SSR and hydrated on the client
 * - Router automatically scrolls to top on route changes
 * - Notifications are cleared when navigating between routes
 * - All modules in `src/modules/` are automatically installed
 */
export const createApp = ViteSSG(
  App,
  { routes },
  (ctx) => {
    // Pinia
    const pinia = createPinia()
    ctx.app.use(pinia)
    const recaptchaSiteKey = import.meta.env.VITE_RECAPTCHA_SITE_KEY
    if (recaptchaSiteKey) {
      ctx.app.use(install, {
        sitekey: recaptchaSiteKey,
        cnDomains: false,
      })
    }

    if (import.meta.env.SSR) {
      ctx.onSSRAppRendered(() => {
        ctx.initialState.pinia = pinia.state.value
      })
    }
    else {
      pinia.state.value = ctx.initialState.pinia || {}
    }

    // Router
    ctx.router.beforeEach((to, from, next) => {
      // Smooth scroll to top when route changes (only in browser)
      if (typeof window !== 'undefined') {
        window.scrollTo({
          top: 0,
          behavior: 'smooth',
        })
      }
      next()
    })
    ctx.router.afterEach(() => {
      const { clearAll } = useNotification()
      clearAll()
    })

    // Modules
    const modules: Module = import.meta.glob('./modules/*.ts', { eager: true })

    // install all modules under `modules/`
    Object.values(modules).map(m => m.install?.(ctx))
  },
)

/**
 * @function includedRoutes
 * @description Determines which routes should be pre-rendered during static site generation.
 * This function is called by ViteSSG during the build process to generate static HTML files
 * for all routes, including dynamic routes with parameters.
 *
 * @param {string[]} paths - Array of static route paths discovered by vite-plugin-pages
 * @param {import('vue-router').RouteRecordRaw[]} routes - Array of route records with metadata
 * @returns {Promise<string[]>} Array of all route paths to pre-render, including dynamic routes
 *
 * @example
 * ```typescript
 * // Dynamic routes like /guides/:slug are expanded to:
 * // ['/guides/file-based-routing', '/guides/ssg-data-fetching', ...]
 * ```
 *
 * @throws {Error} May throw if dynamic route generation fails
 *
 * @remarks
 * - Must be exported from main.ts to access Vite environment variables
 * - Uses `getGuideSlugsSync()` from `plugins/vite-ssg-dynamic-routes` plugin to fetch dynamic route paths
 * - Only runs during SSR/build (skipped in browser)
 * - Transforms route records using `flatMap()` as recommended by ViteSSG documentation
 * - Logs route information during build for debugging purposes
 *
 * @see {@link https://github.com/antfu-collective/vite-ssg | ViteSSG Documentation}
 */
export async function includedRoutes(paths: string[], routes: any[]) {
  // Only run during SSR/build - skip in browser
  if (!import.meta.env.SSR) {
    return paths
  }

  console.log(`\n[includedRoutes] Called with ${paths.length} static paths and ${routes.length} route records`)

  try {
    // Use the plugin's getGuideSlugsSync function (SSR-safe, synchronous)
    // Dynamic import ensures it's only loaded during SSR/build and not bundled for browser
    // Use file:// URL for absolute path resolution during SSR (with .ts extension for TypeScript)
    const pluginPath = new URL('../../plugins/vite-ssg-dynamic-routes/index.ts', import.meta.url).href
    const { getGuideSlugsSync } = await import(/* @vite-ignore */ pluginPath)
    const guideSlugs = getGuideSlugsSync()
    const dynamicRoutePaths = guideSlugs.map(slug => `/guides/${slug}`)

    console.log(`[includedRoutes] Found ${dynamicRoutePaths.length} dynamic routes:`, dynamicRoutePaths)

    // According to ViteSSG docs example, use routes.flatMap() to transform route records
    const allRoutes = routes.flatMap((route) => {
      // For the guides dynamic route, return all the specific slug paths
      if (route.path === '/guides/:slug' || route.path === '/guides/[slug]') {
        return dynamicRoutePaths
      }
      // For other routes, return their path as-is
      return route.path
    })

    console.log(`[includedRoutes] Returning ${allRoutes.length} total routes to pre-render`)
    console.log(`[includedRoutes] Routes:`, allRoutes.slice(0, 5), allRoutes.length > 5 ? '...' : '')
    console.log()

    return allRoutes
  }
  catch (error) {
    console.error('❌ Failed to get dynamic routes:', error)
    // Fallback to static paths only - don't fail the build
    console.warn('⚠️ Falling back to static paths only')
    return paths
  }
}
